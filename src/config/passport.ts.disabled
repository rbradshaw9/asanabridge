import passport from 'passport';
import { Strategy as LocalStrategy } from 'passport-local';
import { Strategy as GoogleStrategy } from 'passport-google-oauth20';
import { Strategy as GitHubStrategy } from 'passport-github2';
import { Strategy as MicrosoftStrategy } from 'passport-microsoft';
import bcrypt from 'bcrypt';
import { prisma } from './database';
import { loadEnv } from './env';
import { logger } from './logger';

const env = loadEnv();

// Serialize user for session
passport.serializeUser((user: any, done) => {
  done(null, user.id);
});

// Deserialize user from session
passport.deserializeUser(async (id: string, done) => {
  try {
    const user = await prisma.user.findUnique({
      where: { id },
      include: {
        socialAccounts: true,
        asanaTokens: true
      }
    });
    done(null, user);
  } catch (error) {
    done(error, null);
  }
});

// Local Strategy (Email/Password)
passport.use(new LocalStrategy(
  {
    usernameField: 'email',
    passwordField: 'password'
  },
  async (email, password, done) => {
    try {
      const user = await prisma.user.findUnique({
        where: { email: email.toLowerCase() },
        include: {
          socialAccounts: true,
          asanaTokens: true
        }
      });

      if (!user) {
        return done(null, false, { message: 'Invalid email or password' });
      }

      if (!user.password) {
        return done(null, false, { message: 'Please sign in with your social account' });
      }

      const isValidPassword = await bcrypt.compare(password, user.password);
      if (!isValidPassword) {
        return done(null, false, { message: 'Invalid email or password' });
      }

      // Update last login
      await prisma.user.update({
        where: { id: user.id },
        data: { lastLoginAt: new Date() }
      });

      logger.info('User logged in successfully', { 
        email: user.email, 
        userId: user.id,
        method: 'email'
      });

      return done(null, user);
    } catch (error) {
      logger.error('Local authentication error', error);
      return done(error);
    }
  }
));

// Google Strategy
if (env.GOOGLE_CLIENT_ID && env.GOOGLE_CLIENT_SECRET) {
  passport.use(new GoogleStrategy({
    clientID: env.GOOGLE_CLIENT_ID,
    clientSecret: env.GOOGLE_CLIENT_SECRET,
    callbackURL: `${env.BACKEND_URL}/auth/google/callback`
  },
  async (accessToken, refreshToken, profile, done) => {
    try {
      const email = profile.emails?.[0]?.value?.toLowerCase();
      if (!email) {
        return done(new Error('No email provided by Google'), null);
      }

      // Check if social account already exists
      let socialAccount = await prisma.socialAccount.findUnique({
        where: {
          provider_providerId: {
            provider: 'GOOGLE',
            providerId: profile.id
          }
        },
        include: { user: true }
      });

      if (socialAccount) {
        // Update tokens
        await prisma.socialAccount.update({
          where: { id: socialAccount.id },
          data: {
            accessToken,
            refreshToken,
            expiresAt: refreshToken ? new Date(Date.now() + 60 * 60 * 1000) : null
          }
        });

        // Update last login
        await prisma.user.update({
          where: { id: socialAccount.userId },
          data: { lastLoginAt: new Date() }
        });

        logger.info('User logged in via Google', { 
          email, 
          userId: socialAccount.userId 
        });

        return done(null, socialAccount.user);
      }

      // Check if user exists with this email
      let user = await prisma.user.findUnique({
        where: { email }
      });

      if (!user) {
        // Create new user
        user = await prisma.user.create({
          data: {
            email,
            name: profile.displayName,
            avatar: profile.photos?.[0]?.value,
            signupMethod: 'GOOGLE',
            emailVerified: true,
            lastLoginAt: new Date()
          }
        });

        logger.info('New user created via Google', { 
          email, 
          userId: user.id 
        });
      }

      // Create social account link
      await prisma.socialAccount.create({
        data: {
          userId: user.id,
          provider: 'GOOGLE',
          providerId: profile.id,
          providerEmail: email,
          accessToken,
          refreshToken
        }
      });

      return done(null, user);
    } catch (error) {
      logger.error('Google authentication error', error);
      return done(error);
    }
  }));
}

// GitHub Strategy
if (env.GITHUB_CLIENT_ID && env.GITHUB_CLIENT_SECRET) {
  passport.use(new GitHubStrategy({
    clientID: env.GITHUB_CLIENT_ID,
    clientSecret: env.GITHUB_CLIENT_SECRET,
    callbackURL: `${env.BACKEND_URL}/auth/github/callback`
  },
  async (accessToken: string, refreshToken: string, profile: any, done: any) => {
    try {
      const email = profile.emails?.[0]?.value?.toLowerCase();
      if (!email) {
        return done(new Error('No email provided by GitHub'), null);
      }

      // Similar logic to Google strategy
      let socialAccount = await prisma.socialAccount.findUnique({
        where: {
          provider_providerId: {
            provider: 'GITHUB',
            providerId: profile.id
          }
        },
        include: { user: true }
      });

      if (socialAccount) {
        await prisma.socialAccount.update({
          where: { id: socialAccount.id },
          data: { accessToken, refreshToken }
        });

        await prisma.user.update({
          where: { id: socialAccount.userId },
          data: { lastLoginAt: new Date() }
        });

        return done(null, socialAccount.user);
      }

      let user = await prisma.user.findUnique({
        where: { email }
      });

      if (!user) {
        user = await prisma.user.create({
          data: {
            email,
            name: profile.displayName || profile.username,
            avatar: profile.photos?.[0]?.value,
            signupMethod: 'GITHUB',
            emailVerified: true,
            lastLoginAt: new Date()
          }
        });
      }

      await prisma.socialAccount.create({
        data: {
          userId: user.id,
          provider: 'GITHUB',
          providerId: profile.id,
          providerEmail: email,
          accessToken,
          refreshToken
        }
      });

      return done(null, user);
    } catch (error) {
      logger.error('GitHub authentication error', error);
      return done(error);
    }
  }));
}

// Microsoft Strategy
if (env.MICROSOFT_CLIENT_ID && env.MICROSOFT_CLIENT_SECRET) {
  passport.use(new MicrosoftStrategy({
    clientID: env.MICROSOFT_CLIENT_ID,
    clientSecret: env.MICROSOFT_CLIENT_SECRET,
    callbackURL: `${env.BACKEND_URL}/auth/microsoft/callback`,
    scope: ['user.read']
  },
  async (accessToken: string, refreshToken: string, profile: any, done: any) => {
    try {
      const email = profile.emails?.[0]?.value?.toLowerCase();
      if (!email) {
        return done(new Error('No email provided by Microsoft'), null);
      }

      // Similar logic to other strategies
      let socialAccount = await prisma.socialAccount.findUnique({
        where: {
          provider_providerId: {
            provider: 'MICROSOFT',
            providerId: profile.id
          }
        },
        include: { user: true }
      });

      if (socialAccount) {
        await prisma.socialAccount.update({
          where: { id: socialAccount.id },
          data: { accessToken, refreshToken }
        });

        await prisma.user.update({
          where: { id: socialAccount.userId },
          data: { lastLoginAt: new Date() }
        });

        return done(null, socialAccount.user);
      }

      let user = await prisma.user.findUnique({
        where: { email }
      });

      if (!user) {
        user = await prisma.user.create({
          data: {
            email,
            name: profile.displayName,
            avatar: profile.photos?.[0]?.value,
            signupMethod: 'MICROSOFT',
            emailVerified: true,
            lastLoginAt: new Date()
          }
        });
      }

      await prisma.socialAccount.create({
        data: {
          userId: user.id,
          provider: 'MICROSOFT',
          providerId: profile.id,
          providerEmail: email,
          accessToken,
          refreshToken
        }
      });

      return done(null, user);
    } catch (error) {
      logger.error('Microsoft authentication error', error);
      return done(error);
    }
  }));
}

export { passport };
